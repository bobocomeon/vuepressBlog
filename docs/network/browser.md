浏览器

csp
<mate http-equiv="Content-Security-Policy" content="default-src https;">
禁止向其他域提交数据
限制其他域的资源加载
dom层面限制不同源的js脚本对当前dom对象的读取操作
数据层面限制不同源站点读取当前cookie indexdb, localstorage的读取
网络层面限制XMLHttpRequest
js图片不会跨域

xss攻击带来的危害，获取cookie信息，修改操作dom，发送恶意请求，在页面生成弹窗广告
存储型： 常见通过评论等方式，提交恶意代码到服务器，前后端都未将代码过滤，然后用户浏览时，在页面渲染中直接执行，恶意脚本执行过程中会将cookie带到服务器，也可以是生成广告弹窗
反射型：恶意脚本属于本地的一部分，然后网站又把恶意js脚本返回了用户，然后这段js脚本在用户页面中执行，很常见的是在搜索的时候，通过key-walue方式发送给服务器，直接把value值返回过来，包含了恶意代码
在现实生活当中，黑客经常会通过qq群或论坛诱导用户点击，web服务器不会存储xss恶意脚本
dom型：代理劫持，wifi路由器和本地恶意软件
不相信任何用户输入，对标签转译，特别是常见的<>，充分利用CSP，禁止内联代码执行，以及外域的资源文件，禁止向不同域提交资源，利用cookie的httponly属性在开发中少用v-html、innerhtml等语法
csrf，这是用户在A网站登录之后，有了A网站的登录态，被恶意人员引诱到了B网站，B网站是黑客构造好的代码，可以自动利用图片发送get请求，或利用post构建表单发送，向A网站发送请求，这时候是以A的身份发送的请求，会自动带上A等登录信息，这是利用用户对浏览器的信息
充分里面cookie的samesie属性，常见有严格，（禁止任何） lax，（get请求，a标签跳转）none无限制
csrf token，在html生成一个csrftoken，每次请求都带上验证
验证origin reffer

http对称加密和非对称加密，但是用户涉及到信任的问题，所以就需要CA机构来生成数字证书
浏览器向服务器发送client-random,加密套件列表
服务端接收后从浏览器支持的加密套件列表选择加密方法，生成server-random，以及自己的公钥
浏览器接收结合client-random和server-random生成随机数pre-random用公钥加密，服务端收到后用公钥解密，得到密串
但是中间交换密钥很容易被中间人截取替换
所以站点需先向CA机构提交自己的公钥、站点信息认证，CA审核通过会签发认证的数字证书，里面包含了站点信息，公钥、CA的信息、有效时间、证书编号，这些信息都是明文的，同时包含一个CA生成的签名

浏览器收到服务端的数字证书后，会对证书进行验证，首先浏览器读取证书中相关的明文信息，采用CA签名时相同的Hash函数来计算并得到信息摘要A，然后再利用对应CA的公钥解密签名数据，得到信息摘要B，对比两个是否一致

```js

```


- requestAnimationFrame
比如60Hz刷新率，也就是1秒刷新60次，16.6ms刷新一次，这个时候浏览器的渲染间隔时间就没必要小于16.6ms，但是RAF会保证浏览器渲染之前一定会被调用，但是并不再Eventloop生命周期里。在执行 animation  callback 时也有可能产生微任务（比如 promise 的 callback），会放到 animation queue  处理完后再执行。所以微任务并不是像之前说的那样在每一轮 Eventloop 后处理，而是在 JS 的函数调用栈清空后处理。
- requestIdlecallback
当宏任务队列中没有任务可以处理，浏览器可能会处于空闲状态，这段空闲时间可以被requestIdlecallback利用起来一些优先级不高，不必立即执行的任务。为了防止浏览器一直处于繁忙状态，提供了一个额外的timeout参数，为这个任务设置一个截止时间。浏览器可以根据这截止时间规划这个任务的执行。

### js解析和执行
解析阶段： 将js代码生成AST，抽象语法树
生成字节码： 解释器将AST转换成字节码，字节码是AST和机器码之间，需要将其转换成机器码才能执行，为啥要有这一步呢，因为直接转换会带来内存过大的问题，这一步除了不能优化外，还能执行部分字节码
生成机器码：根据分析数据的情况生成优化好的机器码，性能更好。
垃圾回收阶段： 将程序中不再使用的内存空间进行回收