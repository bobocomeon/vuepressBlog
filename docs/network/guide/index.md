# 网络
## 首屏加载
- 用户能看到第一屏区域内所有元素加载完成的时间就是首屏加载时间，一个页面的总加载时间一定大于等于首屏加载时长
### 首屏由图片
- 通常需要考虑首屏时间的页面，都是应为在首屏位置放入了较多的图片资源，而图片资源处理是异步的，会先将图片长宽应用于页面排版，随着接收到的图片数据由上至下绘制显示，并且浏览器对每个页面的tcp连接数限制，使得并不是所有图片都能立刻开始下载和显示
- 所以我们需要获取首屏内最后一张图片加载完的时间(绑定首屏内所有图片的load事件)，然后减去navigationStart时间，则为首屏加载时间。
- 具体步骤，绑定首屏内所有图片的load事件，页面加载完成判断图片是否在首屏内，找出加载最慢的一张，就是首屏事件
### 首屏无图片
页面处于稳定状态前最后一次DOM变动的时刻 window.performance.timing.navigationStart， 背景图片的加载不会触发DOM的变动

## http2
多路复用： 采用同一个域名下采用一个tcp链接发送多个url请求，能充分利用带宽，最大限度规避tcp慢启动带来的问题，
服务端推送：在浏览器刚请求html的时候就提前把可能用到的js、css文件发送给客户端，减少等待的延迟
二进制分帧： 区别于http1.1里面的纯文本，而是使用二进制格式，大大方便了计算机的解析，在使用纯文本的时候，需要多大小写、空白字符、回车换行等进行编码转换，效率低，二进制里只有0和1，可以严格按照标准格式，方便解析
还把原来的header+body的消息打散，headers帧存放头数据，data帧存放实体数据，同一个消息往返的帧会分配一个唯一流ID，可以把他它想象成一个虚拟的数据流，在里面流动的是一串由先后顺序的数据帧。多个请求和响应之间没有顺序关系，不需要排队等待，就不会有http对头阻塞的问题，降低了延迟，大幅度提高了链接利用率
头部压缩： 开发了专门的HAPACK算法，在客户端和服务器建立字典，用索引号表示重复的字符串，就不需要每次携带大量重复的header，只需要携带变化的字段即可，大大提高传输效率

## tcp和udp的特点
- tcp会有对头阻塞，慢启动，建立链接延迟等特点，而udp是一个面向无连接的协议，数据传输前，源端和终端不需要建立连接，只会尽可能快的将数据仍到网络上，不保证数据正确到达
- tcp比udp头部字段更多，说明相同情况下控制开销更多，在一定情况下传输数据的延时更大，就不适用于即使场景，tcp还存在多个控制位，意味者会交互更多的控制信息，会有syn，ack等字段，在建立连接时候会进行握手，传输信息会更加可靠，还有窗口位，就意味者有拥塞控制优势，
- udp有数据报文头部数据长度，udp有数据长度字段，而tcp没有，意味者udp是一包一包数据传输，发送端和接收端不会分片或者重组，能很快识别到数据包，而tcp是流，每次都是数据块。
tcp在发送数据前面增加了握手，虽然保证了可靠性，但是同样带来了更多的控制开销和延时

## http3（quic）
- http2解决了http对头阻塞，带来了多路复用功能，带来了很大的性能提升，但是在tcp传输过程中，由于单个数据包的丢失而造成的阻塞成为tcp的对头阻塞，
- 由于http2多个请求跑在一个tcp管道内，如果其中任意一个数据流出现丢包的情况，那么就会阻塞该tcp链接中的所有请求

- 实现了类似tcp的流量控制，传输可靠性，虽然udp不提供可靠性的传输，但quic在udp的基础上增加了一层保证数据可靠性传输，他提供了数据包重传/拥塞控制以及其他tcp存在的特性
- 实现了http2中的多路复用功能，quic实现了在同意物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了tcp对头阻塞。
- 实现快速握手功能，

## 同源策略
当一个资源和该资源本身所在服务器不同域名 端口 协议，请求该资源是，资源会发起一个跨域请求
dom层面
请求层面XMLHttpRequest
数据层面 indexdB localStorage

### csrf
- 首先用户登录一个银行网站，然后gmail服务器返回一些登录状态给david的浏览器，这些信息包括了cookie、session，这样就处理登录状态了
- 接着黑客通过各种手段引诱用户去打开他的连接，比如hacker.com,然后在该域名下想银行网站发送了一个转账请求，
- 由于用户已经登录了银行网站，这个时候是已用户的身份发起的，这样网络请求发送成功，钱也顺利转走了，这是利用了用户对浏览器的信任

在黑客的页面可自动法请get请求，已经构建表单，自动发起post请求， 引诱用户点击链接
xss是csp，禁止内联js代码执行，以及外域资源文件，禁止想第三方域提交数据
充分利用cookie的samesite属性， strict lax（get提交表单或从第三方站点打开） none
验证请求来源站点origin referer
csrf token
重要接口增加验证码


### 输入url到页面展示
- 输入url后浏览器会判断该url是否符合，如果不符合格式则会用浏览器默认的搜索引擎进行搜索，是正确的url就会在缓存进行读取是否存在缓存
- 构建网络请求行，包括请求方法， http协议 以及路径
- 网络进行会在本地资源进行查找是否缓存了该资源，如果有缓存资源就直接返回给服务器，否则开发发起网络请求
- 会进行dns解析， 读取本地host文件，本地dns，本地dns服务器，这个过程是递归，如果没有根域名进行查找，一直找到域名对应的ip地址，返回给客户端，
- 建立tcp链接，会先通过tcp建立三次握手，然后进行数据传输
- 客户端发送http，有请求行和请求头以及请求体
- 网络响应： 请求到达服务器，进行对应的处理，最后把数据传给服务器，返回网络请求，主要包括状态码，响应头以及响应报文。
- 完成网络请求和响应，网络进程开始解析请求头，如果发现返回的状态码是301或302，就会认为是重定向，读取location字段重新发送请求
- 响应数据类型处理： 更具content-type来区分响应数据类型，如果content-type是text/html，就会按照html格式来解析
- 渲染进程接受到提交文档的消息，和网络进行建立通道，渲染进程开始页面解析以及子资源加载。
- 构建dom数，浏览器无法直接理解返回来的html字符串，会将拿到的字节流通过特定的编码转换为字符流，，在通过词法分析和语法分析转换给都没树，在解析过程中遇到link标签，会被认为是需要请求css，会进行请求，在将请求回来的字节流转换为字节流，在解析构建成css规则数
- 计算出dom树中每个节点的具体样式，计算过程中会遵守css的继承和重叠的规则

### https中间人攻击https中间人攻击
- 本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器
- 中间人服务器返回中间人自己的证书
- 客户端创建随机数
- 通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输
- 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密
- 中间人以客户端的请求内容再向正规网站发起请求
- 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据
- 中间人凭借与正规网站建立的对称加密算法对内容进行解密
- 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输
- 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密

### typescript 的 type 和 interface 的区别
- type可以声明基本类型，联合类型和元组，interface不行
- 继承type和interface不是互斥的，可以互相继承
- interface可以声明合并，type不行
- type也可以implement，但是不可以通过联合类型去实现类
- 可以定义多个相同的interface，这些定义将要合并为一个，对于类型别名就不成立，因为类型别名是独一无二的实体。
[可参考](https://github.com/into-piece/Step-By-Step/issues/27)

总结高频问题

## 从浏览器地址栏输入url到请求返回发生了什么
可以延展出很多情况，考虑进去
### 进行url解析，根据dns系统进行ip查找
- url为啥要解析
  - 网络标准规定了URL只能是字母和数字，还有一些其他特殊符号`(@ & = + $ , / ? # [ ])`,比较常见的是不包括百分号和双引号
- encodeURIComponent和encodeURI有什么区别
  - `encodeURIComponent`编码范围更广，时候给参数编码，`encodeURI`适合给url本省`location.origin`编码,一版项目里面都是用qs库处理
- dns查询的规则是什么
  - 比如查询网址浏览器中输入`baidu.com`,会先查询hosts文件是否有记录，有的话把对应`ip`地址进行返回
  - hosts文件没有就去查本地`dns解析器`是否有缓存
  - 再去我们计算机上配置的`dns服务器`上是否有没有缓存
  - 没找到缓存就去找DNS服务器,然后可以找到`.com域名`是哪个服务器管理，查找到对应的ip，再去`.baidu.com`服务器是否能解析，直到查到`www.baidu.com`的ip地址

前端的dns优化，可以再html页面头部写入dns缓存地址
```
<meta http-equiv="x-dns-prefetch-control" content="on" />
<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />
```
### 查到ip之后就是http协议的三次握手和四次挥手
tcp是`可靠，面向连接，字节流`单播协议，在发送数据前，通信双方必须在彼此间建立一条连接，所谓连接即客户端和服务器的内存里保存的一份关于对方的信息，如`ip地址、端口号`等。

tcp可看成一种字节流，它会处理IP层或以下的丢包、重复以及错误问题，在连接的建立过程中，双方需要交换一些参数，在写参数在`TCP头部`。
```
ACK 确认，使得确认号有效
RST 重置连接
SYN 初始化连接序列号
FIN 改报文段的发送发以及结束向对方发送数据
ACK报文是用来应答，SYN报文是用来同步
```
#### 三次握手
1. 客户端发送一个`SYN段`，并指明客户端的初始序列号`seq=x`。
2. 服务端发送自己的`SYN`作为应答，同样指明自己的`seq`，为了确认客户端的`SYN`，将自己的`seq+1`作为`ACK`数值,这样没发送一个SYN，序列号就会加1，如果有丢失的情况，就会重传。
3. 为了确认服务器端的`SYN`，客户端将`seq+1`作为返回的ACK数值。

#### 四次挥手
1. 客户端发送一个`FIN段`，并包含一个希望接受者看到自己当前`序列号K`，同时还包含一个`ACK`表示确认对方最近一次发过来的数据。
2. 服务端将`k值加1`，作为`ACK序号值`，表明收到了上一个包，这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。
3. 服务端发起自己的FIN段，`ACK=K+1、seq=L4`,客户端确认，`ACK=L+1`。

### cnd的工作原理
1. 用户向`www.a.com`下制定资源发送请求时，首先向本地DNS发起域名解析请求
2. 本地DNS检查是否有`www.a.com`的IP地址记录，有就直接返回，否则向授权DNS查询
3. 当授权DNS解析`www.a.com`时，返回域名`CNAME` => `www.a.com`对应的ip地址
4. 域名解析请求发送到DNS调度系统，并分配最佳节点ip地址
5. 本地DNS获取DNS返回的解析IP地址
6. 用户获取解析IP地址
7. 用户向获取ip地址发起对该资源的请求访问
- 如果该IP地址对应的节点已缓存该资源，则直接将数据返回给用户
- 如果对应的ip地址未缓存该资源，则节点向向源站点发起该资源的请求，结合用户的配置的缓存策略，将资源缓存在该节点。
<!-- ![avatar](../.vuepress/public/images/cdn.png) -->

### url到页面展示
- 输入url按下回车会先进行判断是否复合url规则，是关键字搜索还是请求的url
  - 如果是搜索内容，浏览器会用默认的搜索引擎来合成带搜索的关键字
  - 如果是url，会将url请求通过进程中通信把请求发送给网络进程，网络进程会去读取本地网络缓存，如果有就直接返回资源。否则就进入网络请求流程
- 会进行dns解析，dns会读取host文件是否有映射，以及本地dns上的缓存，没有就到本地dns服务器进行查找，没有就要去顶级域名服务器进行递归查找，
一直找到对应的ip地址为止，然后发送到本地dns服务器进行缓存，再返回给客户端
- tcp连接，拿到ip地址之后会建立tcp连接，通过三次握手后建立数据传输，
- 发送http请求，会构建请求行，请求行包含请求方法，http版本，以及路径。构建请求报文和请求体
- 网络响应，到达服务器之后，服务器会经网络响应请求，进行响应的处理，根据请求数据生成响应报文发送给客户端
- 重定向： 客户端的网络进行接收到响应报文后，会判断状态是否是301或302，如果需要重定向会读取响应报文中的location字段，重新发起请求
- 会读取响应报文中的content-type字段，是html格式还是需要进行下载。
- 浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起通信，网络进程和渲染进程建立数据传输通道，渲染进程便进行页面解析以及子资源加载
- 浏览器无法直接解析html文档，会解析构建成dom树，会将拿到的字节流通过特定的编码转化为字符流，再通过词法分析和语法分析构建成dom树，在解析html的过程中遇到css文件也会进行加载，
也是将下载会在字节流转化为字符流在通过词法分析和语法分析构建成css规则树，构建css规则树和dom树是并行执行的。
- 计算出dom树每个节点的具体样式，遍历dom树种的可见节点，加入布局树中，忽略不可见节点，创建布局树，结算每个节点的具体样式
- 创建复合图层，有transform属性、opacity不为1，css属性为absolute和fixed，并且z-index不为1
- 进行图层绘制，渲染引擎将这些图层拆分成一个个的绘制指令，再将这些指令封装成绘制列表，绘制列表是用来保存绘制顺序和绘制指令的
- 栅格化操作，主线程向合成线程发送消息，将绘制列表提交过去，合成线程会根据当前视窗的位置来进行绘制，生成实际的位图，通过栅格化操作生成实际的位图，通过栅格化会使用gpu加速，生成的位图也保存在gpu中，
- 栅格化完成之后，合成线程发送一个绘制指令，gpu就进行位图的绘制，生成图像进行显示。
